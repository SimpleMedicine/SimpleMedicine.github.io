<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/01/21/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/01/21/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><h2 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h2><p>在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。<br>它被所有需要进行实例化的客户类调用。</p><p><img src="simple_factory.png" alt="simple_factory"></p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 目标接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Product</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSome</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 目标接口实现类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteProduct</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Product</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSome</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;ConcreteProduct doSome()&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 简单工厂</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleFactory</span> </span>&#123;<br>    <span class="hljs-function">Product <span class="hljs-title">createProduct</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcreteProduct();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调用简单工厂创建实例</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SimpleFactory simpleFactory = <span class="hljs-keyword">new</span> SimpleFactory();<br>        Product product = simpleFactory.createProduct();<br>        product.doSome();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2><p>定义了一个创建对象的抽象类, 由抽象类的子类决定要实例化哪个类<br>也可以这么理解: 工厂方法把实例化操作推迟到子类</p><p><img src="factory_method.png" alt="factory_method"></p><p>工厂方法是简单工厂的延迟实现，即将超级工厂(简单工厂)拆分为多个工厂<br><img src="factory_method_2.jpg" alt="factory_method_2"></p><p>代码实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Product</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Factory</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Product <span class="hljs-title">factoryMethod</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSome</span><span class="hljs-params">()</span></span>&#123;<br>        Product product = factoryMethod();<br>        <span class="hljs-comment">// do something with the product</span><br>        product.f();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteFactory1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Factory</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">factoryMethod</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcreteProduct1();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteFactory2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Factory</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">factoryMethod</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcreteProduct2();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteProduct</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Product</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;ConcreteProduct::f()&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteProduct1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Product</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;ConcreteProduct1::f()&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteProduct2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Product</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;ConcreteProduct2::f()&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Factory factory;<br>        factory = <span class="hljs-keyword">new</span> ConcreteFactory();<br>        factory.doSome();<br>        factory = <span class="hljs-keyword">new</span> ConcreteFactory1();<br>        factory.doSome();<br>        factory = <span class="hljs-keyword">new</span> ConcreteFactory2();<br>        factory.doSome();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">ConcreteProduct::f()<br>ConcreteProduct1::f()<br>ConcreteProduct2::f()<br></code></pre></td></tr></table></figure><h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><p>提供一个抽象工厂接口，创建一个产品家族，也就是很多对象，并且这些对象是相关的，必须要一起创建出来。而工厂方法模式只是用于多个工程创建一种对象</p><p><img src="abstract_factory.png" alt="abstract_factory"></p><p>抽象工厂也实现了将创建对象的方法延迟到子类实现，例如上图中的AbstractFactory创建Product的方法都由ConcreteFactory1和ConcreteFactory2来实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 抽象工厂类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractFactory</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">abstract</span> AbstractProductA <span class="hljs-title">createProductA</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">abstract</span> AbstractProductB <span class="hljs-title">createProductB</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractProductA</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractProductB</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteFactory1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractFactory</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function">AbstractProductA <span class="hljs-title">createProductA</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ProductA1();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function">AbstractProductB <span class="hljs-title">createProductB</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ProductB1();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteFactory2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractFactory</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function">AbstractProductA <span class="hljs-title">createProductA</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ProductA2();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function">AbstractProductB <span class="hljs-title">createProductB</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ProductB2();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductA1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProductA</span></span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductA2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProductA</span></span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductB1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProductB</span></span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductB2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProductB</span></span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调用简单工厂创建实例</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        AbstractFactory abstractFactory = <span class="hljs-keyword">new</span> ConcreteFactory1();<br>        AbstractProductA productA = abstractFactory.createProductA();<br>        AbstractProductB productB = abstractFactory.createProductB();<br>        <span class="hljs-comment">// do something with productA,B</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三种方法的区别"><a href="#三种方法的区别" class="headerlink" title="三种方法的区别"></a>三种方法的区别</h2><h3 id="简单工厂-1"><a href="#简单工厂-1" class="headerlink" title="简单工厂"></a>简单工厂</h3><p>是工厂方法的一种特例，有一个默认的实现类来实现他的所有功能</p><p>举例：1个工厂生产1种对象<br>    1个工厂：工厂<br>    1种对象：冰箱</p><h3 id="工厂方法-1"><a href="#工厂方法-1" class="headerlink" title="工厂方法"></a>工厂方法</h3><p>是抽象工厂的一种特例</p><p>举例：n个工厂生产1种对象<br>    n个工厂：格力工厂，海尔工厂，海信工厂<br>    1种对象：冰箱<br>                  （格力冰箱，海尔冰箱，海信冰箱）</p><h3 id="抽象工厂-1"><a href="#抽象工厂-1" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><p>在产品等级（同一个牌子）和产品族（同一类型的电气）两个维度上具有共性</p><p>举例：n个工厂生产n种对象<br>    n个工厂：格力工厂，海尔工厂，海信工厂<br>    n种对象：格力冰箱，格力空调，格力TV，<br>                      海尔冰箱，海尔空调，海尔TV，<br>                      海信冰箱，海信空调，海信TV</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/01/21/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/01/21/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>-–</p><p>title: 装饰者模式</p><p>date: 2021-09-14 10:41:15</p><p>tags:</p><p>-–</p><h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><p>为对象动态添加功能</p><p>Decorator类是一个抽象类, 可以在抽象类中对Component接口的方法进行一些增加, 然后在抽象类的实现类中对增加的方法进行实现, 从而达到一个动态添加功能的目的</p><p>个人认为, 下图中的’ConcreteDecorationAB’更改为’ConcreteComponentAB’更合适</p><p><img src="decoration.png"></p><p>代码实现: </p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 组件(被装饰对象)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doOperation</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 原始组件实现类</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteComponent</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Component</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doOperation</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello &quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 装饰者</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Decorator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Component</span></span>&#123;<br>    <span class="hljs-keyword">protected</span> Component component;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 添加方法后的组件实现类</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteDecoratorA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Decorator</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcreteDecoratorA</span><span class="hljs-params">(Component component)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.component = component;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doOperation</span><span class="hljs-params">()</span> </span>&#123;<br>        component.doOperation();<br>        <span class="hljs-keyword">this</span>.doOther();<br>    &#125;<br>    <span class="hljs-comment">// 添加的功能</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doOther</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;world&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Component component = <span class="hljs-keyword">new</span> ConcreteComponent();<br>        <span class="hljs-comment">// 原始方法</span><br>        component.doOperation();<br>        <span class="hljs-comment">// 装饰(改变引用, 动态增加)</span><br>        component = <span class="hljs-keyword">new</span> ConcreteDecoratorA(component);<br>        <span class="hljs-comment">// 装饰之后的方法</span><br>        component.doOperation();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/01/21/JVM%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/01/21/JVM%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Java为什么能够跨平台"><a href="#Java为什么能够跨平台" class="headerlink" title="Java为什么能够跨平台"></a>Java为什么能够跨平台</h1><p>平台 = 操作系统 + 硬件</p><p>Java程序是首先是经过Java编译器(javac)编译形成字节码文件(.class)，JVM将字节码文件翻译成特定平台下的机器码运行</p><p>所以：<strong>跨平台的是Java程序，不是JVM</strong></p><p>Java编译器将Java程序编译之后的字节码文件都是一样的，但是无法跨平台运行，不同平台版本的JVM虚拟机就是相同的字节码文件翻译为不同平台的机器码来执行，JVM在其中充当的是一个中间层的角色</p><p>这也体现了多态的思想，在多种平台下，JVM翻译的字节码文件有着不同的状态</p><span id="more"></span><h1 id="Java程序执行速度较慢的原因和解决方法"><a href="#Java程序执行速度较慢的原因和解决方法" class="headerlink" title="Java程序执行速度较慢的原因和解决方法"></a>Java程序执行速度较慢的原因和解决方法</h1><p>Java程序编译器编译为class文件之后还不能直接运行，需要通过JVM翻译为机器码才能交给机器执行，这也就决定了Java程序先天的会比本地语言的应用程序慢</p><p>为了解决这个问题，JVM引用了JIT技术来提高虚拟机的编译速度，JIT即Just-In-Time Compiler即时编译器，通过将热点代码编译成本机代码来提高Java程序执行的性能</p><p>这里也是类似于redis中缓存热点数据的思想，其实计算机学科中有很多地方都运用了这种思想来提高程序运行速度，以后有机会的话也更一篇redis的相关文章</p><h1 id="JVM如何识别热点代码"><a href="#JVM如何识别热点代码" class="headerlink" title="JVM如何识别热点代码"></a>JVM如何识别热点代码</h1><p>一般有两个主流探测方法，目前主流方法是后者</p><ul><li>采样</li><li>计数器<ul><li>方法调用计数器</li><li>回边计数器</li></ul></li></ul><p>计数器中存放有一个特定的阈值，当计数器超过阈值溢出了就会触发JIT编译</p><h1 id="Java四种引用类型"><a href="#Java四种引用类型" class="headerlink" title="Java四种引用类型"></a>Java四种引用类型</h1><ul><li><p>强引用</p><ul><li>GC绝不会回收</li></ul></li><li><p>软引用</p><ul><li>如果内存空间足够，则不会被GC回收</li><li>如果内存空间不够，则被GC回收</li></ul></li><li><p>弱引用</p><ul><li>GC线程扫描管辖的内存空间范围，不管内存空间是否足够直接将对象内存空间回收</li></ul></li><li><p>虚引用</p><ul><li>虚引用十分脆弱甚至无法获取到被引用的对象，唯一的作用是当指向的对象被回收之后虚引用本身会被加入到引用队列中，用作记录它指向的对象已被回收</li></ul></li></ul><h1 id="JVM加载一个类的过程"><a href="#JVM加载一个类的过程" class="headerlink" title="JVM加载一个类的过程"></a>JVM加载一个类的过程</h1><p>三个步骤：加载，连接，初始化：</p><ul><li><p>加载</p><p>  将类的class文件读入到内存中，通常是创建一个字节数组来读，然后产生所加载类的对象</p></li><li><p>连接</p><p>  加载完之后的类还不完整，类中的变量还未分配内存和初始化，连接也分为三步</p><ul><li><p>验证</p></li><li><p>准备</p><p>  为静态变量分配内存，并设置默认值</p></li><li><p>解析</p><p>  将符号引用替换为直接引用</p></li></ul></li><li><p>初始化</p><ul><li>如果类存在直接的父类则先初始化父类</li><li>如果类中存在初始化语句则先执行初始化语句(一般是类的构造器方法)<br>  所以：加载静态变量并初始化在加载类之后，初始化类之前</li></ul></li></ul><h1 id="类加载器的种类和作用"><a href="#类加载器的种类和作用" class="headerlink" title="类加载器的种类和作用"></a>类加载器的种类和作用</h1><p>在JDK1.2之后，类加载过程采用双亲委派机制，更好的保证了Java平台的安全性</p><p>JVM自带的Bootstrap是根加载器，其他加载器有且仅有一个父加载器</p><p>类的加载首先请求父类加载器，无能为力时才由其子类加载</p><p>类加载器的种类和作用：</p><ul><li>根加载器（Bootstrap）</li><li>扩展加载器（ExtClassLoader）</li><li>系统加载器（AppClassLoader）</li><li>用户自定义加载器</li></ul><p>根加载器一般用本地代码实现，负责加载JVM核心基础类库</p><p>扩展加载器从系统指定目录 java.ext.dirs 中加载类库，它的父加载器是Bootstrap</p><p>系统加载器从环境变量classpath或者系统属性java.class.path所指定的目录中加载类，它的父加载器是Extension</p><p>用户自定义加载器它的父类是AppClassLoader</p><h1 id="GC和STW"><a href="#GC和STW" class="headerlink" title="GC和STW"></a>GC和STW</h1><p>GC垃圾收集器，帮助Java程序员自动管理内存</p><p>STW：Stop-The-World，是一种全局停顿状态，在执行GC算法时Java程序所有线程都被挂起，让GC线程收集现场内存垃圾</p><h1 id="GC种类"><a href="#GC种类" class="headerlink" title="GC种类"></a>GC种类</h1><ul><li>Serial串行收集器</li><li>ParNew收集器</li><li>Parallel收集器</li><li>Parallel Old收集器</li><li>CMS收集器</li><li>G1收集器</li></ul><p>Serial串行收集器：最古老，但也是最稳定，效率较高的收集器</p><p>ParNew收集器：相当于多线程版本Serial串行收集器</p><p>Parallel收集器：优化系统吞吐量版本的ParNew收集器</p><p>Parallel Old收集器：老版本的Parallel收集器，采用多线程+“标记-整理”算法</p><p>CMS收集器：Concurrent Mark Sweep并发标志+整理，以获取最短回收停顿时间</p><p>G1收集器：面向服务器的垃圾收集器，既满足GC停顿时间高要求，还具备高吞吐量性能要求</p><h1 id="GC回收算法"><a href="#GC回收算法" class="headerlink" title="GC回收算法"></a>GC回收算法</h1><ul><li>标记-清除算法</li><li>复制算法</li><li>标记-压缩算法</li><li>分代收集算法</li></ul><p>标记-清除算法：标记所有需要回收的对象，再回收所有被标记的对象</p><p>复制算法：将可用内存空间划分为两块同等大小的空间，每次只使用其中的一块，一块使用完之后将其中还存活着的对象复制到另一块上面，然后将当前内存空间块清除掉。缺点是浪费空间，有点事回收速度快，没碎片</p><p>标记-压缩算法：标记所有需要回收的对象，将标记的对象全部移动到一端，完成碎片整理，但并没有回收碎片</p><p>分代收集算法：新生代和老年代，根据不同年代采取最适合的收集算法</p><h1 id="Java对象结构"><a href="#Java对象结构" class="headerlink" title="Java对象结构"></a>Java对象结构</h1><ul><li>对象头<ul><li>自身运行时相关数据<br>  哈希码，GC分代年龄，锁标识状态，线程持有锁状态</li><li>对象的类元数据类型<br>  是一个指针</li></ul></li><li>示例数据<ul><li>对象的有效信息<br>  包括父类继承下来的和自己定义的</li></ul></li><li>对齐填充<ul><li>8字节整数倍<br>  因为Java基本数据类型中字节长度最长的是8个字节</li></ul></li></ul><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>最近很不在状态，代码也写得少，新东西也很少接触，总是心不在焉，早上起床就收到敖丙的新文章推送，希望能借这篇文章重新开始学一些东西，走回正轨</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>模板方法模式</title>
    <link href="/2021/10/03/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/10/03/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>模板方法可以将多个接口中重复的部分提取出来<br>运用在算法框架中可以重新定义算法的某些实现步骤，而不改变算法的整体结构</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 主体框架模板</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Template</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">al_start</span><span class="hljs-params">()</span></span>&#123;<br>        step1();<br>        step2();<br>        step3();<br>        step4();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">step1</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;step1&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">step2</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">step3</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">step4</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;step4&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 解法1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Template</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">step2</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;step2 by solution1&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">step3</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;step3 by solution1&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 解法2</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Template</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">step2</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;step2 by solution2&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">step3</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;step3 by solution2&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Template template;<br>        System.out.println(<span class="hljs-string">&quot;solution1----&gt;&quot;</span>);<br>        template = <span class="hljs-keyword">new</span> Solution1();<br>        template.al_start();<br>        System.out.println(<span class="hljs-string">&quot;solution2----&gt;&quot;</span>);<br>        template = <span class="hljs-keyword">new</span> Solution2();<br>        template.al_start();<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 输出结果</span><br><span class="hljs-comment">         * solution1----&gt;</span><br><span class="hljs-comment">         * step1</span><br><span class="hljs-comment">         * step2 by solution1</span><br><span class="hljs-comment">         * step3 by solution1</span><br><span class="hljs-comment">         * step4</span><br><span class="hljs-comment">         * solution2----&gt;</span><br><span class="hljs-comment">         * step1</span><br><span class="hljs-comment">         * step2 by solution2</span><br><span class="hljs-comment">         * step3 by solution2</span><br><span class="hljs-comment">         * step4</span><br><span class="hljs-comment">         * 可见在不改变结构的前提下, 改变了算法具体的步骤</span><br><span class="hljs-comment">         */</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>适配器与外观模式</title>
    <link href="/2021/10/03/%E9%80%82%E9%85%8D%E5%99%A8%E4%B8%8E%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/10/03/%E9%80%82%E9%85%8D%E5%99%A8%E4%B8%8E%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>适配器模式提供桥梁，外观模式体现封装</p><span id="more"></span><h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p>把一个类接口转换为另一个类接口，这两个类接口之间本没有任何关系</p><p>比如说如何在只有lighting接口的苹果手机上使用type-c接口呢？这时候我们就只需要一个转接头就可以了</p><p>用户是Client，苹果手机lighting接口是Target，type-c设备是Adapter，转接头就是Adaptee</p><p><img src="adapter.png" alt="adapter"></p><h1 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h1><p>以书上的鸭子和火鸡经典例子举例：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Duck</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quack</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Turkey</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">gobble</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WildTurkey</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Turkey</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">gobble</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;wild turkey gobble&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">火鸡适配器</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TurkeyAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Duck</span></span>&#123;<br>    Turkey turkey;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TurkeyAdapter</span><span class="hljs-params">(Turkey turkey)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.turkey = turkey;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quack</span><span class="hljs-params">()</span> </span>&#123;<br>        turkey.gobble();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Turkey turkey = <span class="hljs-keyword">new</span> WildTurkey();<br>        Duck duck = <span class="hljs-keyword">new</span> TurkeyAdapter(turkey);<br>        duck.quack();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">输出结果: wild turkey gobble<br></code></pre></td></tr></table></figure><h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><p>外观模式就是封装的思想，将软件实现的细节隐藏在一个黑箱中</p><p>举例一个看电视的过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TVCore</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepareTV</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;prepare tv&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">openTV</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;open tv&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getStream</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;get tv stream&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>TVhelper封装了看电视的具体实现流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TVhelper</span> </span>&#123;<br>    TVCore tvCore = <span class="hljs-keyword">new</span> TVCore();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">watchTV</span><span class="hljs-params">()</span></span>&#123;<br>        tvCore.prepareTV();<br>        tvCore.openTV();<br>        tvCore.getStream();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用户并不关心电视是如何获取直播流的操作<br>用户只需要执行watchTV这个方法看电视即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        TVhelper tVhelper = <span class="hljs-keyword">new</span> TVhelper();<br>        tVhelper.watchTV();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">输出结果: <br>prepare tv<br>open tv<br>get tv stream<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代理模式</title>
    <link href="/2021/09/17/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/09/17/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>代理Porxy提供了目标对象的另一种访问方式，即通过代理对象访问目标对象，并且可选择地在目标对象的目标方法上做一些功能的增强</p><span id="more"></span><p>代理模式的基本实现类结构如下图：</p><p><img src="%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.png" alt="代理模式"></p><p>代理模式有三种实现方法：静态代理，动态代理，cglib代理</p><h1 id="方式一：静态代理"><a href="#方式一：静态代理" class="headerlink" title="方式一：静态代理"></a>方式一：静态代理</h1><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 共同的接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Subject</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 真实对象，即被代理的对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RealSubject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Subject</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;static_proxy.RealSubject::doSomething()&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 代理对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxySubject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Subject</span></span>&#123;<br>    <span class="hljs-keyword">private</span> RealSubject realSubject;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        第一种：通过传值的形式，把实列化对象传过来。</span><br><span class="hljs-comment">        （理解为装饰器模式了）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ProxySubject</span><span class="hljs-params">(RealSubject realSubject)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.realSubject = realSubject;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        第二种：采用类加载器形式，去加载实列对象，</span><br><span class="hljs-comment">        这样我们就不同关心到底什么时候需要真实的实列化对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ProxySubject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException </span>&#123;<br>        <span class="hljs-keyword">this</span>.realSubject = (RealSubject) <span class="hljs-keyword">this</span>.getClass().getClassLoader().loadClass(<span class="hljs-string">&quot;static_proxy.RealSubject&quot;</span>).newInstance();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;<br>        realSubject.doSomething();<br>        <span class="hljs-comment">// 这里可以放一些功能增强的代码</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;第一种方式(类加载器形式)&quot;</span>);<br>            <span class="hljs-keyword">new</span> ProxySubject().doSomething();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;第二种方式(传值)&quot;</span>);<br>        <span class="hljs-keyword">new</span> ProxySubject(<span class="hljs-keyword">new</span> RealSubject()).doSomething();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 输出结果</span><br><span class="hljs-comment"> */</span><br>第一种方式(类加载器形式)<br>static_proxy.RealSubject::doSomething()<br>第二种方式(传值)<br>static_proxy.RealSubject::doSomething()<br></code></pre></td></tr></table></figure><h1 id="方式二：动态代理"><a href="#方式二：动态代理" class="headerlink" title="方式二：动态代理"></a>方式二：动态代理</h1><p>动态代理主要通过调用JDK的InvocationHandler接口来实现代理功能，所以动态代理也成为JDK代理，接口代理</p><p>以下用一个螳螂捕蝉黄雀在后的例子来形象地说明动态代理中各种类之间的关系，这里也借鉴了一些傲丙的文章</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 共同接口，基础业务类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BaseService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mainService</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 蝉</span><br><span class="hljs-comment"> * 被代理的类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cicada</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BaseService</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mainService</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;主要业务，蝉，当蝉出现业务调用时，螳螂监听到&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 螳螂</span><br><span class="hljs-comment"> * 实现调用处理器接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrayingMantis</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> BaseService baseService;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PrayingMantis</span><span class="hljs-params">(BaseService baseService)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.baseService = baseService;<br>    &#125;<br><br>    <span class="hljs-comment">// 螳螂的主要任务，也就是监听对象</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        method.invoke(baseService,args); <span class="hljs-comment">// 基础业务</span><br>        secondaryMain(); <span class="hljs-comment">// 增强业务</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 可理解为增强业务</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">secondaryMain</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;螳螂捕蝉 - 次要业务&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上基本实现了代理的基本功能，二级代理也是一样的原理，在一级代理的基础上再代理一层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 黄雀类，模拟二级代理</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cardinal</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;<br>    <span class="hljs-comment">// 监听代理代理对象</span><br>    <span class="hljs-keyword">private</span> Object proxyOne;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Cardinal</span><span class="hljs-params">(Object proxyOne)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.proxyOne = proxyOne;<br>    &#125;<br><br>    <span class="hljs-comment">// 螳螂主要业务 也就是监听对象</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        method.invoke(proxyOne,args); <span class="hljs-comment">// 一级代理对象基础功能</span><br>        secondaryMain(); <span class="hljs-comment">// 二级代理对象增强功能</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">secondaryMain</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;黄雀吃螳螂 - 次要任务&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来测试一下代码运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Client类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanFactory</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BaseService <span class="hljs-title">newInstance</span><span class="hljs-params">(Class classFile)</span></span>&#123;<br>        <span class="hljs-comment">// 1. 创建蝉，真实类对象</span><br>        BaseService trueCicada = <span class="hljs-keyword">new</span> Cicada();<br>        <span class="hljs-comment">// 2. 创建代理类 螳螂</span><br>        <span class="hljs-comment">// prayingMantis是trueCicada的代理</span><br>        InvocationHandler prayingMantis = <span class="hljs-keyword">new</span> PrayingMantis(trueCicada);<br>        <span class="hljs-comment">// 3. 向JVM索要代理对象 其实就是监听的对象</span><br>        Class classArray[] = &#123;BaseService.class&#125;;<br>        BaseService baseService = (BaseService) Proxy.newProxyInstance(classFile.getClassLoader(),classArray,prayingMantis);<br><br>        <span class="hljs-comment">// 二级代理</span><br>        InvocationHandler cardinal = <span class="hljs-keyword">new</span> Cardinal(baseService);<br>        BaseService secondBaseService = (BaseService) Proxy.newProxyInstance(classFile.getClassLoader(),classArray,cardinal);<br>        <span class="hljs-keyword">return</span> secondBaseService;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        BaseService baseService = newInstance(Cicada.class);<br>        baseService.mainService();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 输出结果</span><br><span class="hljs-comment"> */</span><br>主要业务，蝉，当蝉出现业务调用时，螳螂监听到<br>螳螂捕蝉 - 次要业务<br>黄雀吃螳螂 - 次要任务<br></code></pre></td></tr></table></figure><p>从上面的代码可以看出，代理类中最核心的方法是invoke方法，在该方法中完成被代理对象的方法以及调用增强功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br><span class="hljs-comment">// do something...</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="方式三：cglib代理"><a href="#方式三：cglib代理" class="headerlink" title="方式三：cglib代理"></a>方式三：cglib代理</h1><p>前两种方式都是要求目标对象实现某个接口，但是当目标对象没有实现任何接口，只是一个单独的对象的时候，可以使用cglib代理来是实现代理的功能</p><p>cglib代理不需要目标对象实现任何接口，cglib是通过继承目标对象，以子类的方式来实现代理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 目标对象类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSome</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;调用原始MyClass类的doSome()方法&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里需要注意：实现MethodInterceptor接口需要导入cglib.jar包，或者导入spring.core包也可以，spring包中包括了cglib包</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 代理对象，实现方法拦截器接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;<br>    <span class="hljs-comment">// 维护一个目标对象</span><br>    <span class="hljs-keyword">private</span> Object target;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ProxyFactory</span><span class="hljs-params">(Object target)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.target = target;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取代理对象实例</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getProxyInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">// Enhancer工具类</span><br>        Enhancer en = <span class="hljs-keyword">new</span> Enhancer();<br>        <span class="hljs-comment">// 设置目标对象</span><br>        en.setSuperclass(target.getClass());<br>        <span class="hljs-comment">// 设置回调函数, 表示代理的逻辑放在哪，可以是一个日志对象</span><br>        en.setCallback(<span class="hljs-keyword">this</span>);<br>        <span class="hljs-comment">// 创建代理对象</span><br>        <span class="hljs-keyword">return</span> en.create();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方法拦截器</span><br><span class="hljs-comment">     * 将目标对象的方法拦截下来，可以做一些方法的增强或者其他的代理功能</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object obj,</span></span><br><span class="hljs-params"><span class="hljs-function">                            Method method,</span></span><br><span class="hljs-params"><span class="hljs-function">                            Object[] args,</span></span><br><span class="hljs-params"><span class="hljs-function">                            MethodProxy proxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        <span class="hljs-comment">// 执行目标对象的方法</span><br>        proxy.invokeSuper(obj, args);<br>        System.out.println(<span class="hljs-string">&quot;--调用一些其他不关心的方法或者控制访问的权限--&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 目标对象</span><br>        MyClass myClass = <span class="hljs-keyword">new</span> MyClass();<br>        <span class="hljs-comment">// 代理对象</span><br>        MyClass proxy = (MyClass) <span class="hljs-keyword">new</span> ProxyFactory(myClass).getProxyInstance();<br>        proxy.doSome();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 输出结果</span><br><span class="hljs-comment"> */</span><br>调用原始MyClass类的doSome()方法<br>--调用一些其他不关心的方法或者控制访问的权限--<br></code></pre></td></tr></table></figure><h1 id="代理模式和装饰者模式的区别"><a href="#代理模式和装饰者模式的区别" class="headerlink" title="代理模式和装饰者模式的区别"></a>代理模式和装饰者模式的区别</h1><p>都可以实现方法的增强功能，但是实现的角度不一样</p><p>代理模式：在编译期间就确定好需要增强的功能，一些调用者并不关心，或者被调用者不希望调用者知道实现细节的方法。代理模式也可以实现对对象访问权限的控制，比如不同角色对数据库数据进行操作之前都需要先登录账号，代理模式可以代理角色对象，验证当前用户是否登录，再调用数据库的invoke方法进行数据库查询的操作<br>装饰者模式：在运行期间动态地增加需要增强的功能，虽然我的功能增强了，但还是我，而且当前装饰类可以无限被装饰(无限增强功能)</p><p>如果还是无法理解的话，可以看以下几个通俗的例子：</p><p>例子一：买房子<br>装饰者模式：买毛坯房，房子的具体装修自己设计<br>代理模式：直接买精装房，不关心如何装修，只关心是否可以拎包入住</p><p>例子二：钢铁侠<br>装饰者模式：史塔克穿反浩克装甲<br>代理模式：但是史塔克没有能力自己穿，需要让贾维斯帮自己从太空上叫下来<br>反浩克装甲有无数个(装饰者模式可以无限增强)<br>贾维斯只有一个(代理模式不会无限代理)</p><p>例子三：保护自己<br>装饰者模式：靠自己每天吃蛋白粉变壮变强，出去不怕被人欺负了<br>代理模式：请一个保镖保护自己，自己还是那个自己，体格没有改变，但出去也不怕被欺负了</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>静态代理：实现一个共同的接口</li><li>动态代理：实现JDK的API，重写invoke方法</li><li>cglib代理：实现cglib中的方法拦截器MethodInterceptor，工具类Enhancer创建代理类，拦截器intercept实现功能增强</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例模式</title>
    <link href="/2021/09/16/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/09/16/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>单例模式是为了确保在当前进程中，创建的类有且仅有一个实例</p><p>有三种实现思想：懒汉式，饿汉式，枚举类</p><span id="more"></span><p>首先需要理清楚一个问题：</p><h1 id="什么是懒汉式？什么是饿汉式？"><a href="#什么是懒汉式？什么是饿汉式？" class="headerlink" title="什么是懒汉式？什么是饿汉式？"></a>什么是懒汉式？什么是饿汉式？</h1><p>懒汉式：默认不会实例化，什么时候用什么时候new<br>我是这么理解的，懒汉他很懒，别人不来调用这个类创建对象他就不创建对象，死猪不怕开水烫，在类空间里面摆烂</p><p>饿汉式：类加载的时候就被实例化，并且创建单例对象<br>我是这么理解的，饿汉他很饿，别人第一次调用这个类的时候他就已经把对象加载好了</p><h1 id="方法一：懒汉式非线程安全"><a href="#方法一：懒汉式非线程安全" class="headerlink" title="方法一：懒汉式非线程安全"></a>方法一：懒汉式非线程安全</h1><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getUniqueInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 延迟实例化对象，节省资源</span><br>        <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-keyword">null</span>) &#123;<br>            uniqueInstance = <span class="hljs-keyword">new</span> Singleton();<br>        &#125;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是这个方法是非线程安全的，因为当有多个线程进入getUniqueInstance()方法的时候，并且此时uniqueInstance = null，则会有多个线程执行new语句，导致实例化多次，违反单例模式目的</p><h1 id="方法二：懒汉式线程安全"><a href="#方法二：懒汉式线程安全" class="headerlink" title="方法二：懒汉式线程安全"></a>方法二：懒汉式线程安全</h1><p>只是粗暴的在getUniqueInstance()方法上加上synchronized</p><p>但是这回使得所有对象未被实例化的线程进入等待状态，导致线程阻塞时间过长，在性能上会有一些损失</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title">getUniqueInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 延迟实例化对象，节省资源</span><br>        <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-keyword">null</span>) &#123;<br>            uniqueInstance = <span class="hljs-keyword">new</span> Singleton();<br>        &#125;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="方法三：饿汉式线程安全"><a href="#方法三：饿汉式线程安全" class="headerlink" title="方法三：饿汉式线程安全"></a>方法三：饿汉式线程安全</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance = <span class="hljs-keyword">new</span> Singleton();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>利用JVM的static静态变量来达到单例模式的目的<br>但是这个方法也失去了延迟实例化对象带来的节省资源的优点</p><h1 id="方法四：双重校验锁"><a href="#方法四：双重校验锁" class="headerlink" title="方法四：双重校验锁"></a>方法四：双重校验锁</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getUniqueInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-keyword">null</span>) &#123;<br>                    uniqueInstance = <span class="hljs-keyword">new</span> Singleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>两个if语句：第一个if语句为了避免已被实例化后的加锁操作，第二个if语句是在加锁之后的一个线程进入，就不会出现多个线程同时进行实例化的操作</li><li>volatile：由于JVM具有指令重排的特性，在new的时候可能会出现在多线程情况下指令混乱的情况，可能一个uniqueInstance还未被初始化就被返回，使用volatile可以禁止JVM指令重排，保证在多线程环境下new语句可以正常执行</li></ul><p>但是volatile会屏蔽掉JVM中的一些必要的代码优化，所以执行效率不是很高，下面介绍的静态内部类实现是一个更好的解决方法</p><h1 id="方法五：静态内部类实现"><a href="#方法五：静态内部类实现" class="headerlink" title="方法五：静态内部类实现"></a>方法五：静态内部类实现</h1><p>当Singleton类被加载时，静态内部类SingletonHolder不会被加载。只有在调用getUniqueInstance()方法时SingletonHolder类才会被加载</p><p>所以这个方法同时达成了 对象延迟初始化 和 JVM提供多线程支持 两个优点<br>也可以理解为懒汉式的一种</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonHolder</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getUniqueInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>还有更加完美的方法：</p><h1 id="方法六：枚举"><a href="#方法六：枚举" class="headerlink" title="方法六：枚举"></a>方法六：枚举</h1><p>从根本上解决了多线程的问题，因为枚举类式线程安全的，而且只会被装载一次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonObject</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonObject</span><span class="hljs-params">()</span></span>&#123;&#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Singleton</span></span>&#123;<br>        INSTANCE;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SingletonObject instance ;<br>        Singleton()&#123;<br>            instance = <span class="hljs-keyword">new</span> SingletonObject();<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">private</span> SingletonObject <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> instance;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonObject <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> Singleton.INSTANCE.getInstance();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>由上述例子可以总结出一些单例模式的特点：</p><ul><li>可以保证该对象只有一个实例对象</li><li>构造器必须私有的，外部类无法通过构造器方法创建该实例</li><li>没有公开的set方法，外部类无法调用set方法创建该实例</li><li>只提供一个公开的get方法获取唯一的实例对象</li></ul><p>单例模式又有哪些优点呢：</p><ul><li>省去了new操作符，降低了系统内存的使用频率，对于一些大型的对象，这可能会是一比十分巨大的系统开销</li><li>系统中的某些对象可能控制着处理流程，如果该类可以创建多个实例对象的话，系统完全乱了，比如spring里存放在容器中的bean对象们</li><li>避免对资源的重复占用</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>观察者模式</title>
    <link href="/2021/09/14/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/09/14/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>观察者模式定义对象之间的一对多的关系</p><span id="more"></span><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p>Observer</p><p>定义对象之间的一对多的关系, 当一个对象的状态改变时, 他的所有依赖都会收到通知并且自动更新动态<br>主题Subject ——&gt; 观察者Observer</p><p><img src="XgIct6FGkRwaumE.png" alt="observer.png"><br><img src="FXaIKw4rldBUgyG.png" alt="observer_2.png"></p><p>代码实现:</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 主题接口</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Subject</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">registerObserver</span><span class="hljs-params">(Observer observer)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">notifyObservers</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeObserver</span><span class="hljs-params">(Observer observer)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 观察者接口</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Observer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 主题</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteSubject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Subject</span></span>&#123;<br>    List&lt;Observer&gt; observerList = <span class="hljs-keyword">new</span> ArrayList&lt;Observer&gt;();<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerObserver</span><span class="hljs-params">(Observer observer)</span> </span>&#123;<br>        observerList.add(observer);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyObservers</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(Observer observer : observerList)&#123;<br>            observer.update();<br>        &#125;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeObserver</span><span class="hljs-params">(Observer observer)</span> </span>&#123;<br>        observerList.remove(observer);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 观察者</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observer</span></span>&#123;<br>    Subject subject;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcreteObserver</span><span class="hljs-params">(Subject subject)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.subject = subject;<br>        subject.registerObserver(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;update&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里需要注意的是: 为什么时Observer类中有Subject而不是Subject中有Observer?<br>原因: 开闭原则, 对扩展开放, 对修改关闭。Subject主题是我们已经确定好的类，现在需要做出改变的只是多几个订阅者(也就是观察者)，实现对当前系统的一个扩展。用户也不需要知道主题类如何添加一个观察者，只需要知道将观察者注册到哪个主题即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 新建主题</span><br>        Subject subject = <span class="hljs-keyword">new</span> ConcreteSubject();<br>        <span class="hljs-comment">// 注册观察者(观察者订阅主题服务)</span><br>        Observer observer1 = <span class="hljs-keyword">new</span> ConcreteObserver(subject);<br>        Observer observer2 = <span class="hljs-keyword">new</span> ConcreteObserver(subject);<br>        Observer observer3 = <span class="hljs-keyword">new</span> ConcreteObserver(subject);<br>        <span class="hljs-comment">// 主题更新并通知所有观察者</span><br>        <span class="hljs-comment">// subject.dosomehing()主题状态发生改变, 具体细节这里不做实现</span><br>        subject.notifyObservers();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决hexo中图片资源无法显示的问题</title>
    <link href="/2021/09/14/%E8%A7%A3%E5%86%B3hexo%E4%B8%AD%E5%9B%BE%E7%89%87%E8%B5%84%E6%BA%90%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2021/09/14/%E8%A7%A3%E5%86%B3hexo%E4%B8%AD%E5%9B%BE%E7%89%87%E8%B5%84%E6%BA%90%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>解决hexo中图片资源无法显示的问题</p><span id="more"></span><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>晚上在打算更新博客的时候发现网站图片资源无法加载出来，在网上找了几天解决方法也不能很好的解决这个问题，但是网上的贴子也给我提供了一定的解决思路，也借此总结了以下hexo博客插入图片的方法</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>大概的思路：把所有有关的软件版本全部更新到最新版本。<br>所包括的软件有：vscode, hexo, blog插件</p><h3 id="更新vscode"><a href="#更新vscode" class="headerlink" title="更新vscode"></a>更新vscode</h3><p>在设置中自动更新到官方最新版本（当前使用版本1.60.0）</p><h3 id="更新hexo"><a href="#更新hexo" class="headerlink" title="更新hexo"></a>更新hexo</h3><p>更新使用淘宝的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">npm install -g cnpm --registry=https://registry.npm.taobao.org<br></code></pre></td></tr></table></figure><p>建立软连接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /usr/bin<br>ln -s /usr/local/node/bin/cnpm cnpm<br></code></pre></td></tr></table></figure><p>更新hexo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cnpm install -g cnpm# 升级npm<br>cnpm cache clean -f# 清除缓存<br></code></pre></td></tr></table></figure><p>更新插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">cnpm install -g npm-check# 检查有哪些可升级的插件<br>cnpm install -g npm-upgrade# 升级系统中的插件<br><br>cnpm update# 更新hexo及所有插件<br>hexo -v# 检查hexo版本确认已更新<br></code></pre></td></tr></table></figure><p><strong>接下来图片就可以正常显示了（至少我的博客是这样的），接下来再总结一下hexo插入图片的方法：</strong></p><h3 id="方法一：绝对引用"><a href="#方法一：绝对引用" class="headerlink" title="方法一：绝对引用"></a>方法一：绝对引用</h3><p>将图片资源保存在 /pics 文件下（文件名是自定义的），通过绝对地址来插入图片<br>注意：根目录 /pics 是在 /source 文件夹目录之下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">![image-20210913215821170](/pics/image-20210913215821170.png)<br></code></pre></td></tr></table></figure><p><img src="/pics/image-20210913215821170.png" alt="image-20210913215821170"></p><p>经验证 pics 文件下的文件夹中的图片也支持绝对引用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">![image-20210913215821170](/pics/Typora图片资源测试/image-20210913215821170.png)<br></code></pre></td></tr></table></figure><p><img src="/pics/Typora%E5%9B%BE%E7%89%87%E8%B5%84%E6%BA%90%E6%B5%8B%E8%AF%95/image-20210913215821170.png" alt="image-20210913215821170"></p><h3 id="方法二：相对引用"><a href="#方法二：相对引用" class="headerlink" title="方法二：相对引用"></a>方法二：相对引用</h3><p>更新站点配置文件 _config.yml 下的配置命令，可以在每次新建文章的时候就会建立同名文件夹，在使用Typora编写文章时将图片放入同名文件夹即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">post_asset_folder: true# 改为true<br></code></pre></td></tr></table></figure><p>之后，直接调用命令可直接访问图片资源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">![image-20210913215821170](image-20210913215821170.png)<br></code></pre></td></tr></table></figure><p><img src="image-20210913215821170.png" alt="image-20210913215821170"></p><p>但是值得注意的是：同样的目录结构在Typora和hexo中引用的路径不一样，所以需要每次上传的时候手动更改图片资源的引用路径，这个目前还没有找到特别有效的解决方法，除非使用在线图床</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> Typora</span><br>![image-20210913215821170](Typora图片资源测试/image-20210913215821170.png)<br><span class="hljs-meta">#</span><span class="bash"> hexo</span><br>![image-20210913215821170](image-20210913215821170.png)<br></code></pre></td></tr></table></figure><h3 id="方法三：在线图床"><a href="#方法三：在线图床" class="headerlink" title="方法三：在线图床"></a>方法三：在线图床</h3><p>个人推荐一个比较好用的图床 <a href="https://sm.ms/">sm.ms</a> ，点击上传之后直接赋值连接粘贴过来</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">![image-20210913215821170.png](https://i.loli.net/2021/09/14/F7lHB3AVG8i6Z42.png)<br></code></pre></td></tr></table></figure><img src="%E8%A7%A3%E5%86%B3hexo%E4%B8%AD%E5%9B%BE%E7%89%87%E8%B5%84%E6%BA%90%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/F7lHB3AVG8i6Z42.png" alt="image-20210913215821170.png"  />]]></content>
    
    
    
    <tags>
      
      <tag>BUG</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
